import FileProtocol, { FileEntry, FileError } from "../FileProtocol.js"

/**
 * Helper that attempts to repair a malformed JSONL line.
 *
 * The original ``llimo-unpack`` expected the ``content`` field to contain escaped
 * new‑line characters ("\
"). When a JSONL file is generated by hand or via a
 * simplistic ``JSON.stringify`` that writes real new‑lines, ``JSON.parse`` fails with
 * "Bad escaped character" because the line now spans multiple physical lines.
 *
 * This function detects such a situation and tries to turn the raw new‑lines back
 * into their escaped form before parsing. If the repair also fails we re‑throw the
 * original error so callers can handle it as before.
 */
function safeParse(line) {
	try {
		return JSON.parse(line)
	} catch (original) {
		// Replace real new‑line characters inside the JSON string literals with
		// escaped "\n". This is a heuristic – it works for the typical payloads
		// produced by ``llimo-pack`` where only the "content" value may contain
		// line breaks.
		//
		// We first locate the "content" property value and then escape its inner
		// new‑lines. The regex is deliberately simple and assumes standard JSON
		// quoting.
		const match = line.match(/"content"\s*:\s*"([\s\S]*?)"(?=,|\})/)
		if (!match) throw original // cannot repair – re‑throw
		const raw = match[1]
		// Escape back‑slashes first, then new‑lines.
		const escaped = raw
			.replace(/\\/g, "\\\\") // preserve existing escapes
			.replace(/\r?\n/g, "\\n")
		const repaired = line.replace(match[0], `"content":"${escaped}"`)
		return JSON.parse(repaired)
	}
}

export default class JSONL extends FileProtocol {
	/**
	 * @param {AsyncGenerator<string>} stream – an async iterator yielding one line per call.
	 * @returns {Promise<{ correct: FileEntry[], failed: Error[] }>}
	 */
	static async parseStream(stream) {
		/** @type {FileEntry[]} */
		const correct = []
		/** @type {Error[]} */
		const failed = []
		let i = 0
		for await (const rawLine of stream) {
			++i
			let line = rawLine.trim()
			if (!line) continue // skip empty lines
			try {
				const data = safeParse(line)
				if (!data.filename) {
					throw new Error("Property filename must be defined")
				}
				correct.push(new FileEntry(data))
			} catch (/** @type {any} */ err) {
				const matches = String(err.message).match(/column (\d+)\)$/)
				let target = ""
				const shift = 33
				if (matches) {
					const index = Math.max(0, parseInt(matches[1] - 1))
					const start = index > shift ? index - shift : 0
					const limit = index > shift ? shift : index + 1
					console.log(index, start, limit)
					target = line.slice(start, start + limit + shift) + "\n"
					target += "   " + "—".repeat(limit - 1) + "^" + "—".repeat(shift) + "\n"
				}
				failed.push(
					new FileError({
						line: i,
						content: rawLine,
						error: [
							`Unable to parse JSON line #${i}:\n`,
							`   ${line.slice(0, shift * 2)}${line.length > shift * 2 ? "…" : ""}\n`,
							`   ${target}`,
							`   ${err.message}\n\n`,
						].join("\n")
					})
				)
			}
		}
		return { correct, failed }
	}
}
